<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css" />
<!--[if lt IE 9]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.ie.min.css" />
<![endif]-->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Econ 34430</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-pencil"></span>
     
    Homeworks
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="static-labor-supply.html">Static LS</a>
    </li>
    <li>
      <a href="dynprog-HotzMiller.html">Hotz and Miller</a>
    </li>
    <li>
      <a href="hw-lifecycle-solutions.html">Lifecycle Model</a>
    </li>
    <li>
      <a href="dynamic-labor-supply.html">Dynamic LS</a>
    </li>
    <li>
      <a href="earnings-mixtures.html">Mixtures</a>
    </li>
    <li>
      <a href="ShimerSmith.html">Sorting</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/tlamadon/econ-34430">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/tlamadon/econ-34430/issues">
    <span class="fa fa-bug"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<div id="dynamic-programing" class="section level1">
<h1>Dynamic programing</h1>
<p>Let’s consider a simple dynamic programing problem. In this problem set we want to simulate from a single agent problem and use the Hotz and Miller approach to recover the parameters.</p>
<div id="setting-the-environment" class="section level2">
<h2>Setting the environment</h2>
<p>Let’s use a very simple model that we can solve exactly. The state space will be discrete, we will consider a two sector problem and staying at thome. We will use Rust assumptions. For simplicity we consider only 10 years.</p>
<p>We consider the following preferences:</p>
<p><span class="math display">\[ U(w,a,\xi) = \gamma \cdot \underbrace{\frac{w^{1-\rho}}{1-\rho}}_{u_0(w)} + u(a) +  \xi(a)\]</span> where <span class="math inline">\(\xi(a)\)</span> is an iid, type 1 extreme value shock, and <span class="math inline">\(u(a)\)</span> is a permanent preference vector. We consider the following wage equation:</p>
<p><span class="math display">\[ \log(w_{it}(a)) = \beta_a E_{it} + \beta_r t +  \epsilon_{it}(a) \]</span> where <span class="math inline">\(E_{it}\)</span> is a stochastic observed experience value. <span class="math inline">\(\epsilon(a)\)</span> is iid and normaly distributed. The agent does not know the <span class="math inline">\(\epsilon(a)\)</span> at the time where she decides which action <span class="math inline">\(a\)</span> to choose. As we know we can solve for the expected value function given by:</p>
<p><span class="math display">\[ \bar{V}_t(x) = \log \sum_a \exp \Big[  \mathbb{E} U(w,a,\xi) + \beta \sum_{x_{t+1}}\bar{V}_t(x_{t+1}) g(x_{t+1}|a) \Big] + \gamma_c\]</span> because of the log-normal shocks we get that</p>
<p><span class="math display">\[
\begin{align*}
\mathbb{E}_\epsilon U(w,a,\xi) &amp;=   \gamma  \cdot \underbrace{\exp \Big( (1-\rho)^2 \sigma_\epsilon^2/2) \Big)}_{S} \cdot  \underbrace{\frac{ (\beta_a E_{it} + \beta_r t)^{(1-\rho)} }{1-\rho}}_{u_0(\mathbb{E}\log w)} + u(a) +  \xi(a) \\
&amp;=\gamma  S \cdot  u_0(\mathbb{E} \log w) + u(a) +  \xi(a)
\end{align*}.
\]</span></p>
<div id="preparing-the-environment" class="section level3">
<h3>Preparing the environment</h3>
<p>We set parameters and initialize the transition matrices, value functions and Q-values.</p>
<pre class="r"><code># setting paramters
initp &lt;-function() {
  p    = list(nt=10, # nb of periods
              ne=10, # nb of experience level
              rho=2, # risk aversion
              wsd=1, # standard deviation of wage shock epsilon
              r1=0.1,r2=0,rt=0.05,   # return to experience in activity 1 and 2, and age effect 
              u0=0,u1=5,u2=4,  # preference values for each choice
              r=0.02,
              gamma=1.2) # discount paramter
}

gc = -digamma(1) # Euler constant

# construct transition matrix for each choice
trm &lt;- function(d,s,n) {
  X1 = spread(qnorm( (1:n)/(n+1) ),1,n)
  D = dnorm( X1 - (t(X1) +d),0,s)
  D = D / spread(rowSums(D),2,n) 
}

# function to initialize the model
model.init &lt;- function(p) {
  # init value function
  V    = array(0,c(p$nt,p$ne))
  # init Q-value
  QQa = array(0,c(p$nt,p$ne,3))
  # global transition matrix
  GG = array(0,c(3,p$ne,p$ne))
  GG[1,,] = trm(-0.2,0.1,p$ne)  # when not working, epxerience depreciates
  GG[2,,] = trm(0   ,0.1,p$ne)  # in activity 2, experience does not accumulate
  GG[3,,] = trm(1   ,0.1,p$ne)  # in activity 3, experience accumulates
  return(list(V=V,QQa=QQa,GG=GG))
}

# define utility function
uf &lt;- function(w,p) p$gamma*(w^(1-p$rho))/(1-p$rho)</code></pre>
</div>
<div id="solving-dynamic-problem" class="section level3">
<h3>Solving dynamic problem</h3>
<p>We then solve the values recursively</p>
<pre class="r"><code>model.solve &lt;- function(model,p) {
  
  V = model$V
  Vf = model$Vf
  QQa = model$QQa
  GG = model$GG

  # scaling due to the shock
  S = exp( p$wsd^2 * (1-p$rho)^2/2) 
  
  # final values (get the same choice for ever)
  Vf = cbind( p$u0 , S*uf( exp(p$r1 * (1:p$ne) + p$rt*p$nt) ,p) +p$u1, S*uf( exp(p$r2 * (1:p$ne) + p$rt*p$nt) ,p) + p$u2)/p$r
  V[p$nt,] = log( rowSums(exp(Vf))) + gc
  QQa[p$nt,,] = Vf

  # construct Q value for each choice of the 3 choices
  for (t in (p$nt-1):1) {
    Q0 =                               p$u0  + 1/(1+p$r)* GG[1,,] %*% V[t+1,]
    Q1 =  S*uf(exp(p$r1 * (1:p$ne) + p$rt*t) ,p) + p$u1  + 1/(1+p$r)* GG[2,,] %*% V[t+1,]
    Q2 =  S*uf(exp(p$r2 * (1:p$ne) + p$rt*t) ,p) + p$u2  + 1/(1+p$r)* GG[3,,] %*% V[t+1,]
    QQ = cbind(Q0,Q1,Q2)
    V[t,] = log(rowSums(exp(QQ))) + gc
    
    # saving the choice probability
    QQa[t,,] = QQ
  }
  
  model$V = V
  model$QQa = QQa
  model$S = S
  model$Vf = Vf
  return(model)
}</code></pre>
</div>
<div id="simulating" class="section level3">
<h3>Simulating</h3>
<p>Then we simulate a data set:</p>
<pre class="r"><code>model.simulate &lt;- function(model,p,N) {
  
  V = model$V
  Vf = model$Vf
  QQa = model$QQa
  GG = model$GG
  
  simdata = data.table(ii=1:N)
  R = c(0,p$r1,p$r2)
  
  dE = 1:p$nt
  dW = 1:p$nt
  dA = 1:p$nt
  
  simdata = simdata[,{
    dE[1] = sample.int(p$ne,1,prob=1/(1:p$ne))
    for (t in 1:p$nt) {
      pr = exp(QQa[t,dE[t],] - max(QQa[t,dE[t],]))
      dA[t] = sample.int(3,1,prob= exp(QQa[t,dE[t],]))
      dW[t] = exp(R[dA[t]] * dE[t] + p$rt*t + p$wsd*rnorm(1))
      if (dA[t]==1) dW[t]=NA;
      if (t&lt;p$nt) {dE[t+1] = sample.int(p$ne,1,prob=GG[dA[t],dE[t],])}
    }
    list(A=dA,W=dW,E=dE,t=1:p$nt)
  },ii]
  return(simdata)
}</code></pre>
<p>We can simulate and look at some stats:</p>
<pre class="r"><code>p = initp()
model = model.init(p)
model = model.solve(model,p)
simdata = model.simulate(model,p,10000)

rr = simdata[,.N,list(A,t)][,pr:=N/sum(N),t]
ggplot(rr[t&lt;10],aes(x=t,y=pr,color=factor(A))) + geom_line() +ggtitle(&quot;Average choices over time&quot;) + theme_bw()</code></pre>
<p><img src="dynprog-HotzMiller_files/figure-html/analysis-1.png" width="672" /></p>
<pre class="r"><code>rr = simdata[,list(m=mean(E),q975=quantile(E,0.975),q025=quantile(E,0.025)),t]
ggplot(rr,aes(x=t,y=m,ymin=q025,ymax=q975)) + geom_line() + geom_errorbar(width=0.2) +ggtitle(&quot;value of E over time&quot;) + theme_bw()</code></pre>
<p><img src="dynprog-HotzMiller_files/figure-html/analysis-2.png" width="672" /></p>
</div>
</div>
<div id="questions" class="section level2">
<h2>Questions</h2>
<p>We want to apply the Hotz and Miller approach to estimate this dynamic programing problem.</p>
<div id="q1-payoff-equation-and-transition-function" class="section level3">
<h3><strong>Q1</strong> Payoff equation and transition function</h3>
<p>Show that you can recover direclty the parameter of the wage equation in this problem. Write the regression code that recovers them. Also write code that recovers the transition matrices <span class="math inline">\(G_0,G_1,G_2\)</span>. Show that the <span class="math inline">\(G\)</span> estimated matrices align with the true one.</p>
<p>Then do a parametric estimation by imposing the known form for the transition and recover the slope and variance parameters use for each <span class="math inline">\(a\)</span> in the first part. In other words use a minimum distance to recover the 2 parameters used in the <code>trm</code> function to generate the law of motions.</p>
</div>
<div id="q2-ccp-given-risk-aversion-and-rinfty" class="section level3">
<h3><strong>Q2</strong> CCP given risk aversion and <span class="math inline">\(r=\infty\)</span></h3>
<p>We start with a simple case where there is full discounting. Express <span class="math inline">\(\log(Pr[a=2|E,t] / Pr[a=1|E,t])\)</span> and <span class="math inline">\(\log(Pr[a=3|E,t] / Pr[a=1|E,t])\)</span>. Write down an estimator (which is linear) for <span class="math inline">\(u(a=2)\)</span> and <span class="math inline">\(u(a=3)\)</span> in this case and show that you can get the values from simulated data.</p>
<p>As an intermeidate step, compute the realized choice probability at each <span class="math inline">\(x,t\)</span> with data simulated using <span class="math inline">\(r=\infty\)</span>. Plot each of this probability against the true probability that you can compute using the true parameters. This graph should be close to the 45 degree line.</p>
</div>
<div id="q3-expressing-values-as-linear-function-of-parameters-for-rho-known" class="section level3">
<h3><strong>Q3</strong> Expressing Values as linear function of parameters (for <span class="math inline">\(\rho\)</span> known)</h3>
<p>The risk aversion coefficient does not enter linearly in the utility problem. We are going to fix it, and use the Hotz and Miller approach conditional on the value of <span class="math inline">\(\rho\)</span>. So Assume that <span class="math inline">\(\rho\)</span> is known and fixed at its true value. We need to construct our expressions that will help us recover <span class="math inline">\(u(a=2)\)</span> and <span class="math inline">\(u(a=3)\)</span> in this dynamic case. This requires the use of the Euler cosntant <span class="math inline">\(\gamma_e = 0.577\)</span>.</p>
<p>Let’s start with a simple observation. If you consider a static problem of the form:</p>
<p><span class="math display">\[V = \mathbb{E} \big[ \max_k u_k + \xi_k \big] = \log \sum_k \exp(u_k) + \gamma_c\]</span></p>
<p>we also know that: <span class="math display">\[ Pr[k] = \frac{\exp(u_k)}{\sum_{k&#39;} \exp(u_{k&#39;})} \]</span></p>
<p>but also, we can express <span class="math inline">\(V\)</span> usin these choice probabilities:</p>
<p><span class="math display">\[ V = \sum_k Pr[k] \cdot \big( u_k + \mathbb{E} [\xi_k|k] \big) \]</span> where finally we also know that <span class="math inline">\(\mathbb{E} [\xi_k|k] = \gamma_c - log(Pr[k])\)</span>. This then gives us that:</p>
<p><span class="math display">\[ V = \sum_k Pr[k] \cdot \big( u_k + \gamma_c - log(Pr[k]) \big) \]</span></p>
<p>We then use the recursive formulation of the value function which was:</p>
<p><span class="math display">\[ \bar{V}_t(x) = \log \sum_a \exp \Big[  \mathbb{E} U(w,a,\xi) + \beta \sum_{x_{t+1}}\bar{V}_t(x_{t+1}) g(x_{t+1}|a) \Big] + \gamma_c\]</span></p>
<p>where we have that <span class="math inline">\(\mathbb{E} U(w,a,\xi) = \gamma S u( \exp(\mathbb{E}\log w))\)</span>. At this point we are interested in recovering <span class="math inline">\(u(a)\)</span> and <span class="math inline">\(\gamma\)</span>. We can look at the final period and see that</p>
<p><span class="math display">\[ 
\begin{align*}
\bar{V}_T(x) &amp;=  \mathbb{E} \max_a \Big[ \gamma \cdot S \cdot u_0(\exp(\mathbb{E}[\log w|x,t])) + u(a) \Big] \\
&amp;= \sum_a Pr[a|x,t] \Big(  \gamma \cdot S \cdot u_0(\exp(\mathbb{E}[\log w|x,t])) + u(a) + \gamma_c - \log Pr[a|x,t] \Big) \\
&amp;= \gamma \cdot \Big( \sum_a Pr[a|x,t] \cdot S \cdot u_0(\exp(\mathbb{E}[\log w|x,t])) \Big)  + u(a) \cdot \Big( \sum_a Pr[a|x,t]\Big)  \\
&amp; \hspace{5cm} + \gamma_c - \sum Pr[a|x,t] \log Pr[a|x,t] \\
 \end{align*}
 \]</span></p>
<p>Call <span class="math inline">\(\theta = (\gamma,u(2),u(3))\)</span>, we have found a matrix <span class="math inline">\(B_T\)</span> which is <span class="math inline">\(n_e \times 3\)</span> and a vector <span class="math inline">\(A_T\)</span>, functions only of data and of known parameters, such that <span class="math inline">\(\bar{V}_T = A_T + B_T \theta\)</span>. Strictly speaking we could just recover the parameters directly here! But for the sake of the exercice we are going to use all time periods.</p>
<p>At each period <span class="math inline">\(t\)</span> we have that the flow payoff can be expressed linearly. In other words, there exists a <span class="math inline">\(\tilde{B}_t(a)\)</span> such that <span class="math inline">\(\mathbb{E_t}[u(w_t)|x,a] = \tilde{B}_t(a) \theta\)</span>. We can now express <span class="math inline">\(A_t\)</span> and <span class="math inline">\(B_t\)</span> recursively. I write in matrix form where rows are difference values of <span class="math inline">\(x=E\)</span> and <span class="math inline">\(P_t[a]\)</span> is diagonal matrix with values <span class="math inline">\(Pr[a|t,x]\)</span>:</p>
<p><span class="math display">\[ 
\begin{align*}
\bar{V}_{t} &amp;= \log \sum_a \exp \Big[   S \cdot u_0(\exp(\mathbb{E}_{t} \log w_{t})) + u(a) + \beta \cdot G(a) \times \bar{V}_{t+1} \Big] + \gamma_c \\
&amp; = \log \sum_a \exp \Big[   \tilde{B}_{t}(a) \theta + \beta G(a) (A_{t+1} +  B_{t+1} \theta) \Big] + \gamma_c  \\
&amp; = \sum_a P_t[a] \Big[    \tilde{B}_{t}(a) \theta + \beta G(a) (A_{t+1} +  B_{t+1} \theta)  - \log Pr[a|t,x] \Big] + \gamma_c \\
&amp; = \underbrace{\Big( \sum_a P_t[a] ( \tilde{B}_{t}(a)+ \beta G(a) B_{t+1}) \Big)}_{B_{t}} \theta + \underbrace{ \sum_a \beta  G(a)  P_t[a] A_{t+1} + \gamma_c -  (\sum_a P_t[a] \log P_t[a]) \times  \mathbf{1}}_{A_{t}} 
\end{align*}
\]</span></p>
<p>Where we combine the two terms to construct <span class="math inline">\(B_{t-1},A_{t-1}\)</span> to get:</p>
<p><span class="math display">\[
\begin{align*}
B_{t-1}[x,j] &amp; = \sum_a Pr[a|x,t] \tilde{B}_t(a,x,j) + \beta \sum_a \sum_{x&#39;} Pr[a|x,t] G(a,x&#39;,x) B_{t+1}(x&#39;,j) \\
A_{t-1}[x]   &amp; =  \gamma_c + \beta \sum_a \sum_{x&#39;} Pr[a|x,t] G(a,x&#39;,x)  A_t(x&#39;) - \sum_a Pr[a|x,t] \log Pr[a|x,t]
\end{align*}
\]</span></p>
<p>The current question asks you to write the code that construct this sequence of <span class="math inline">\(B_{t-1},A_{t-1}\)</span> as a function of measured choice probabilities <span class="math inline">\(Pr[a|x,t]\)</span>. Provide such code (note that <code>RcppSimpleTensor</code> can help a lot here). To verify that your code is correct, construct the <span class="math inline">\(B_{t-1},A_{t-1}\)</span> associated with the true probabilities coming constructed from <code>model$QQa</code>, then using the true <span class="math inline">\(\theta\)</span>, plot your generated <span class="math inline">\(A_t + B_t \theta\)</span> against the <code>model$V</code> which should line on the 45 degree line as in the previous question.</p>
</div>
<div id="q4-use-the-ccp-to-get-gamma-and-u2u3" class="section level3">
<h3><strong>Q4</strong> Use the CCP to get <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(u(2),u(3)\)</span></h3>
<p>Compute the choice probabilities in the simulated data <span class="math inline">\(Pr[a|E,t]\)</span>. Use these conditional choice probabilites to reconstruct the values using the procedure you developed in the previous section (here you can use the know parameters for the wage equation). The final step is regress the log ratio of choices on the linear expression to recover <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(u(2),u(3)\)</span> from the simluated dynamic data. Report the estimated paramters (once you have <span class="math inline">\(B_{t-1},A_{t-1}\)</span>, this a linear regression!).</p>
</div>
<div id="q5-full-estimation" class="section level3">
<h3><strong>Q5</strong> Full estimation</h3>
<p>In this final question we want to put it all together: 1. Recover the wage and transition parameters as in the first question 2. Recover <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(u(2),u(3)\)</span> using steps of the previous question for a fixed value of <span class="math inline">\(\rho\)</span> 3. Run the previous step for a grid on <span class="math inline">\(\rho\)</span> (report this plot)</p>
</div>
</div>
</div>

<!--<a href="https://github.com/you"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a> -->
<a class="github-fork-ribbon right-bottom fixed" href="https://github.com/tlamadon/econ-34430" title="Fork me on GitHub">Fork me on GitHub</a>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
