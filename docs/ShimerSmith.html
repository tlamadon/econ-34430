<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title></title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-1.1/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-1.1/highlight.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css" />
<!--[if lt IE 9]>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.ie.min.css" />
<![endif]-->

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">ScPo-GradLabour</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    Home
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-pencil"></span>
     
    Homeworks
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="static-labor-supply.html">Static LS</a>
    </li>
    <li>
      <a href="hw-lifecycle-solutions.html">Lifecycle Model</a>
    </li>
    <li>
      <a href="ShimerSmith.html">Search and Matching - AKM</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/floswald/ScPo-Labor">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/floswald/ScPo-Labor/issues">
    <span class="fa fa-bug"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">




</div>


<div id="worker-and-firm-heterogeneity-shimer-and-smith" class="section level1">
<h1>Worker and firm Heterogeneity: Shimer and Smith</h1>
<p>The goal of this homework is to</p>
<ol style="list-style-type: decimal">
<li>learn how to solve an equilibrium search model and</li>
<li>estimate a two-way fixed effect model on the data generated from the model. We will use the model from Shimer and Smith.</li>
</ol>
<p>This is the version from 2017-04-10. Please check for updates later on.</p>
<pre class="r"><code>  #some imports
require(gtools)
require(data.table)
require(ggplot2)
require(reshape)
require(readstata13)
require(RcppSimpleTensor)
library(testthat)
source(&quot;../../ScPo-Labor-sol/src/search-HW.r&quot;) # you do not have access to this repo which has the solutions! :-) !</code></pre>
<div id="solving-shimer-smith" class="section level2">
<h2>Solving Shimer Smith</h2>
<p>The equilibrium of Shimer and Smith can be solved by iterating on the Bellman equations <span class="math inline">\(W_0\)</span>, <span class="math inline">\(\Pi_0\)</span> and the surplus function <span class="math inline">\(S\)</span>. They are given by:</p>
<p><span class="math display">\[ (r+s)S(x,y) = f(x,y) -r W_0(x) - r \Pi_0(y) \]</span></p>
<p><span class="math display">\[ r W_0(x) = b + \kappa  \alpha \int \max \{ S(x,y&#39;) , 0\} v(y&#39;) dy&#39;\]</span></p>
<p><span class="math display">\[ r \Pi_0(y) = -c + \kappa (1-\alpha)  \int \max \{ S(x&#39;,y) , 0\} u(x&#39;) dx&#39;\]</span></p>
<p>This needs to be jointly solved for with the endogenous distribution of matches <span class="math inline">\(h(x,y)\)</span> which must satify</p>
<p><span class="math display">\[ h(x,y) = (1-s)  h(x,y)  1[S(x,y)\geq 0] + \kappa 1[S(x,y)\geq 0] u(x) v(y)\]</span></p>
<p>Notice that we endogenize the arrival rates here. This means that we had in class</p>
<p><span class="math display">\[ r W_0(x) = b + \lambda  \alpha \int \max \{ S(x,y&#39;) , 0\} \frac{v(y&#39;)}{V} dy&#39;\]</span> where <span class="math inline">\(V=\int v(x)dz\)</span> is the mass of all vacancies. With the matching function <span class="math inline">\(N=m(x,y)\)</span> and <span class="math inline">\(\lambda = \frac{N}{U}\)</span> we define get the above formulation by realizing that <span class="math inline">\(\kappa = \frac{N}{UV}\)</span>.</p>
<p>Here is code that will create a parameter set to initialize your model with some starting values.</p>
<pre class="r"><code>initp &lt;- function(...) {
  p = list()
  p$ay = 0.2
  p$nx = 50     # number of worker types
  p$ny = 50     # number of firm types
  p$sep = 0.02  # separation rate
  p$r   = 0.05  # interest rate
  p$rho = -2    # prod func assortative strength [-2,2]
  p$b   = 0     # unemp
  p$c   = 0     # vacancy cost
  p$alpha = 0.5 # bargaining power
  p$fsize = 50  # firm size
  p$m   = 0.4   # matching function parameter
  p$M= 1.5      # mass of firms / mass of workers
  p$noise = 0.5  # wage disturbance
  
  #p$pf = function(x,y,z=0,p) x*y + z
  p$pf = function(x,y,z=0,p)  ( x^p$rho +  y^p$rho )^(1/p$rho) + p$ay # haggerdorn law manovski 
  
  sp = list(...)
  
  for (n in names(sp)) {
    p[[n]] = sp[[n]]
  }
  
  return(p)
}

#&#39; Spread Array into dimensions
#&#39;
#&#39; this is a utility function that spreads an array into a given dimesion
#&#39; this is like `repmat` in julia/matlab
spread &lt;- function (A, loc, dims) {
  if (!(is.array(A))) {
    A = array(A, dim = c(length(A)))
  }
  adims = dim(A)
  l = length(loc)
  if (max(loc) &gt; length(dim(A)) + l) {
    stop(&quot;incorrect dimensions in spread&quot;)
  }
  sdim = c(dim(A), dims)
  edim = c()
  oi = 1
  ni = length(dim(A)) + 1
  for (i in c(1:(length(dim(A)) + l))) {
    if (i %in% loc) {
      edim = c(edim, ni)
      ni = ni + 1
    }
    else {
      edim = c(edim, oi)
      oi = oi + 1
    }
  }
  return(aperm(array(A, dim = sdim), edim))
}</code></pre>
<p>and here is some code that initializes the different functions needed inside your value function iteration proceedure:</p>
<pre class="r"><code>  X = spread( (0:(p$nx-1))/p$nx , 2, p$ny )  # worker heterogeneity
  Y = spread( (0:(p$ny-1))/p$ny , 1, p$nx )  # firm heterogeneity
  FF = p$pf(X,Y,0,p)                         # production function
  W0 = rep(0,p$nx)                           # value of being unemployed (starting values)
  P0 = rep(0,p$ny)                           # value of a vacancy (starting values)
  H  = array(0.8/(p$nx*p$ny),c(p$nx,p$ny))   # joint mass of matches (starting values)
  U  = rep(0.2/p$nx,p$nx)                    # mass of unemployed  (starting values)
  V  = (p$M-0.8) * rep(1/p$ny,p$ny)          # mass of vacant jobs (starting values)
  S  = FF / p$r                              # surplus of a match (starting values)</code></pre>
<p>As guidance here is how I compute the <span class="math inline">\(S(x,y)\)</span> function and the <span class="math inline">\(\kappa\)</span>. You can use and install <a href="https://github.com/tlamadon/RcppSimpleTensor"><code>RcppSimpleTensor</code></a>, or directly use the <code>spread</code>, <code>colSums</code> and <code>rowSums</code> functions. Note that it can be important to use relaxation parameters such as <code>ctrl$rs</code> here. This is because the Bellman equation is a contraction mapping, but the distribution jointly with the Bellman equations might note be.</p>
<pre class="r"><code>    kp =  pmin(pmin(sum(U), p$m*sum(U)^.5 * sum(V)^.5),sum(V))/(sum(U) * sum(V))
    
    S2 = t.S(FF,W0,P0,p$r) / ( p$r + p$sep)
    dS = mean( (S - S2 )^2 )/mean( (S)^2 )  # distance
    S = ctrl$rs * S + (1-ctrl$rs) * S2  # update by relaxation
    
    wage = p$alpha * (p$sep + p$r) * S + p$r * spread(W0,2,p$ny)</code></pre>
<p><strong>Question 1</strong>: Write a function that will iterate on the value functions and the distributions to find the fix point of the problem. Stop the loop when <code>dS&lt;1e-7</code>. This requires for you to write down the equations to update <span class="math inline">\(H(x,y),V(y),U(x)\)</span>. Getting these flow equations is crucial. Instead of using the adding up constraint, I suggest you try to write the updating equations for H,V,U and then check that the total mass of workers is still 1 at each step of your loop. You may want to stick to this strategy:</p>
<ol style="list-style-type: decimal">
<li>Given current distributions in <span class="math inline">\(U,V\)</span>, compute <span class="math inline">\(\kappa\)</span></li>
<li>Compute <span class="math inline">\(S\)</span>
<ol style="list-style-type: decimal">
<li>Compute a distance measure between <span class="math inline">\(S\)</span> and the previous <span class="math inline">\(S\)</span></li>
<li>update <span class="math inline">\(S\)</span> by relaxation</li>
</ol></li>
<li>Compute <span class="math inline">\(W_0\)</span>
<ol style="list-style-type: decimal">
<li>Update by relaxation</li>
</ol></li>
<li>Compute <span class="math inline">\(\Pi_0\)</span>
<ol style="list-style-type: decimal">
<li>update by relaxation</li>
</ol></li>
<li>Compute <span class="math inline">\(H\)</span>
<ol style="list-style-type: decimal">
<li>Compute a distance measure between <span class="math inline">\(H\)</span> and the previous <span class="math inline">\(H\)</span></li>
<li>update by relaxation</li>
</ol></li>
<li>update <span class="math inline">\(U,V\)</span></li>
<li>Check if distances in <span class="math inline">\(S\)</span> and <span class="math inline">\(H\)</span> are less than tolerance
<ol style="list-style-type: decimal">
<li>if yes, break</li>
<li>else, repeat</li>
</ol></li>
</ol>
<p>To test your code, install the libary <code>test_that</code> and write a few test cases that will verify that your code is doing what you expect it to do! For instance, check that the h and u distribution sum to 1 for each x.</p>
<pre class="r"><code>require(testthat)
test_that(&quot;Testing model sulotion&quot;, {
    expect_true( all(diff(model$W0)&gt;0), &quot;W0 is increasing&quot;)
    expect_true( all(diff(model$P0)&gt;0), &quot;W0 is increasing&quot;)
    expect_true( abs(1-sum(model$H)-sum(model$U))&lt;1e-8, label = &quot;worker mass is 1&quot;)
})  </code></pre>
<p>With the default starting values, you should find the following figure:</p>
<pre class="r"><code>  p &lt;- initp()
  ctrl=list(maxiter=400,rs=0.5,rw=0.5,rh=0.8)
  model = shimersmith.solve(p,ctrl)</code></pre>
<pre><code>## [ 50] dS=2.109e-04 dH=4.333e-03 m=1.000e+00 kp=1.804420
##  [100] dS=1.514e-07 dH=6.059e-05 m=1.000e+00 kp=1.868803
##  [150] dS=2.040e-09 dH=9.005e-06 m=1.000e+00 kp=1.871217
##  [200] dS=1.404e-08 dH=6.431e-06 m=1.000e+00 kp=1.871060
##  [250] dS=1.739e-09 dH=6.185e-04 m=1.000e+00 kp=1.870762
##  [300] dS=1.457e-07 dH=4.679e-06 m=1.000e+00 kp=1.871004
##  [350] dS=4.287e-09 dH=2.063e-05 m=1.000e+00 kp=1.871352
##  [400] dS=3.409e-10 dH=1.246e-06 m=1.000e+00 kp=1.871378
##   all good</code></pre>
<pre class="r"><code>  persp(model$S*(model$S&gt;0))</code></pre>
<p><img src="ShimerSmith_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<pre class="r"><code>  persp(model$H,theta=-30)</code></pre>
<p><img src="ShimerSmith_files/figure-html/unnamed-chunk-3-2.png" width="672" /></p>
</div>
<div id="simulate-a-panel" class="section level2">
<h2>Simulate a panel</h2>
<p><strong>Question 2</strong>: Simulate a panel with N workers over T periods working in M firms. Note that N and M represents the number of IDs, not types. We want to create a <code>data.table</code> with columns <code>i,t,x,y,spell,wage,fid</code>.</p>
<p>You should start by simulating without worrying about the firm ids. Use a double for-loop, on time 1 draw <span class="math inline">\((x,y)\)</span> from the stationary distribution of workers which is <span class="math inline">\(U(x) + H(x,y)\)</span>. Then for this given worker simulate the sequence of events that happens to him:</p>
<ul>
<li>loosing his job if employed,</li>
<li>finding a new job if unemployed,</li>
</ul>
<p>using the outcome of your model. A sequence of events of length T will be a given individuals. When you simulate a given individual, also store the <strong>spell number</strong>. This number should increase when the worker looses his job or finds a new job (this will be useful later). Set <span class="math inline">\(y=0\)</span> when the worker is not employed.</p>
<p><strong>Hint:</strong> When simulating, it is much faster to pre-allocate arrays such as <code>X=array(0,T*N)</code> for each variable, then fill these and create the <code>sim</code> data.table at the very end with <code>sim = data.table(x=X,y=Y,t=T,i=I)</code> and such.</p>
<p>At this point you should have a <code>data.table</code> with columns <code>i,t,x,y,spell</code>. Once we you have simulated this panel, we want to attach firms to spells. We are going to do this is a semi-naive way by randomly attaching firm ids to spells (the firm id needs to be fixed over a spell). Since the separation rate is the same in each job, we do not have to worry to weight them by the length of spells.</p>
<pre class="r"><code># we want to target a given firm size (that should be a parameter of your simulating function)
fsize = 200 
sim = simulate(N,M,fsize)  # you must write function simulate()

# inside `simulate`:
# we get spells information, randomly draw from firm without replacement
spells = unique(sim[y&gt;0,list(i,spell,y)])
# this creates a unique firm id 
spells[, fid:= as.integer(y + p$ny*sample( rep((1:ceiling(.N/fsize)),fsize*1.2),.N,replace=FALSE)),y]

# merge spells back into sim
setkey(spells,i,spell)
setkey(sim,i,spell)
sim[,fid := spells[sim,fid]]

# quick check!
assert_that(sim[,length(unique(y)),fid][,all(V1==1)])</code></pre>
<p><strong>Hint:</strong> here you could make your life much easier if you insure that the firm ids are continuous (no gap) and start at 1. This will be convenient when indexing them later. (that’s what I did above.)</p>
<p>We finish this section by appending the wage. We want to append the equilibrium wage when working and <span class="math inline">\(b\)</span> when not working. Here is a simple way to attach the wage and b:</p>
<pre class="r"><code>sim[y&gt;0, wage := model$wage[x,y]*exp(rnorm(.N)*noise),list(x,y)]
sim[y==0, wage := p$b]</code></pre>
<p><strong>Hint:</strong> The command makes use of many of the functionalities of data.table. When calling <code>sim[param1, param2 ,by=param3]</code>, param1 subset the table, param2 execute a commmand and using <code>:=</code> assigns a new column. Finally param3 allows us to run the param2 within each values of <code>param3</code>, i.e. it <code>group</code>s the command. Within each we then use the variable <code>.N</code> which gives the size of the sub-group within <code>param3</code>, which allows us to draw exactly the right number of iid noises!</p>
<div id="testing-your-simulation-code" class="section level3">
<h3>Testing your simulation code</h3>
<p><strong>Question 3a</strong>: Yes, this is boring, but it will save you time in the end! Check that in your simulated data, you have the correct separation rate and correct matching probability per type! Also check that your simulated unemployment distribution is close to the U you solved for, and same for H. Report a scatter plot for each with true versus simulated.</p>
<p><strong>Question 3b</strong>: Simulate a long time dimension like <span class="math inline">\(T=100\)</span>, then compute the sum of discounted future reward at <span class="math inline">\(t=1\)</span> for each <span class="math inline">\(x\)</span> and each <span class="math inline">\(y\)</span>, including <span class="math inline">\(y=0\)</span>. Take the mean of the expected values and check that it matches <span class="math inline">\(W_0(x)\)</span> when <span class="math inline">\(y=0\)</span> and check that it matches <span class="math inline">\(W_1(x,y)\)</span> for the employed. Report a scatter plot for each with true versus simulated.</p>
</div>
</div>
<div id="estimate-akm" class="section level2">
<h2>Estimate AKM</h2>
<p>We now want to estimate the two-way fixed effect model of Abowd, Kramarz and Margolis. AKM requires to compute the smallest connected set among firms, but we are going to ignore this for now. Because of the way we simulated data, it is very unlikely that the connected set will not encompass all workers/firms.</p>
<p><strong>Important:</strong> form now on, we work with log-wages.</p>
<div id="firm-fix-effects" class="section level3">
<h3>Firm fix effects</h3>
<p>TO estimate AKM we start by focusing on movers and we want to build the firms fix-effects. We are going to estimate it by OLS. We want to create a matrix of dummies for each firm and focus on movers only. Firm select the set of workers that are movers (they need to show up in at least 2 different firms ids). Make this selection using the data.table methods. It should look like:</p>
<pre class="r"><code>movers_id = sim[y&gt;0,list(N = &lt;somthing that computes the number of firms&gt;),by=i][N&gt;=2,i]  # a mover is a worker with more than 2 firms in his history
msim = sim[y&gt;0][i %in% movers_id]</code></pre>
<p>We then create our matrix of regressors with each firm dummies. We want to use sparse matrices for that. Construct a sparse matrix of zeros using the <code>SparseM</code> package. You need to run through your <code>msim</code> table and put ones in the correct columns for each line, and take the wage for the dependent. Once the matrix of regressors and the dependent are constructed, use <code>slm.fit</code> to run a sparse OLS. You now have your firm fixed effects.</p>
<p>Finally, reattach the fixed effect to the data using the firm id. Call that column <code>psi</code>. <strong>Hint</strong> be carefull to correclty match the estimated fixed-effect to the correct firm in <code>sim</code>. This merge can be tricky, because you need to keep track of the <code>fid</code> in the order you put them in the matrix.</p>
</div>
<div id="worker-fixed-effects" class="section level3">
<h3>Worker fixed effects</h3>
<p>We can now recover the worker fix effect by differencing and attaching it to our simulated sample.</p>
<pre class="r"><code>asim = sim[y&gt;0,list(alpha = mean(wage - psi)),i]
setkey(asim,i)
setkey(sim,i)
sim[,alpha := asim[sim,alpha]]</code></pre>
<p><strong>Question 4</strong>: Implement a function that takes your simulated data as input, then extracts both worker and firm fixed effects as suggested and finally reattaces these fixed effects to each row of the simulated data.</p>
</div>
</div>
<div id="variance-analysis" class="section level2">
<h2>Variance analysis</h2>
<p>We are at the end of our work! We now want to check the estimated sorting from AKM and compare it to the true decomposition. To get the variance decomposition of AKM we compute the following:</p>
<pre class="r"><code>fit_akm = lm(wage ~ alpha + psi,sim)
sim$res = residuals(fit)
pred = predict(fit_akm,type = &quot;terms&quot;)
sim$k_hat = pred[,1]
sim$l_hat = pred[,2]
vardec_akm = sim[,cov(data.frame(wage,k_hat,l_hat,res))$cov]</code></pre>
<p>To get the best linear projection we do the folliwing:</p>
<pre class="r"><code>fit = lm(wage ~ factor(x) + factor(y),sim)
sim$res = residuals(fit)
pred = predict(fit,type = &quot;terms&quot;)
sim$k_hat = pred[,1]
sim$l_hat = pred[,2]
vardec_best = sim[,cov.wt( data.frame(y_imp,k_hat,l_hat,res))$cov]</code></pre>
<p><strong>Question 5</strong>: Now we want to compare the best decomposition to the akm decomposition under values of <span class="math inline">\(\rho\)</span> in the production function that spans positive to negative sorting. Ideally we want to compare these under different firm sizes, to measure the incendital parameter bias. The ideal answer her would show that we few movers the correlation can be strongly negatively correlated, however in the case of PAM, with enough data, AKM should not be doing so badly!</p>
</div>
</div>

<!--<a href="https://github.com/you"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png"></a> -->
<a class="github-fork-ribbon right-bottom fixed" href="https://github.com/floswald/ScPo-Labor" title="Fork me on GitHub">Fork me on GitHub</a>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
